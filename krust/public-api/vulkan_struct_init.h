#ifndef KRUST_STRUCT_INIT_H_INCLUDED_E26EF
#define KRUST_STRUCT_INIT_H_INCLUDED_E26EF

// Copyright (c) 2016 Andrew Helge Cox
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/// @note Do not edit this file. It is generated from the Vulkan XML
/// specification by the script at `tools/scripts/gen_info_struct_wrappers.py`.

/**
 * @file Three sets of functions used to initialize Vulkan API structs.
 * 1. Functions to initialize the type ID enum and pNext extension pointer
 *    of Vulkan API structures which require those as their first two fields.
 * 2. Functions to initialize all members of Vulkan API structures, automatically
 *    supplying the type ID and pNext extension pointer while requiring all other
 *    fields to be supplied by the user.
 * 3. Functions initialize all members of small Vulkan structures from parameters
 *    supplied by the user.
 *
 * @see VulkanTaggedStructSimpleInit, VulkanTaggedStructParamsInit,
 *      VulkanUntaggedStructParamsInit
 */

// External includes:
#include <vulkan/vulkan.h>

namespace Krust
{

/**
 * @name VulkanTaggedStructSimpleInit For each Vulkan API struct tagged with a
 * type enum and possessing an extension pointer, a function to initialize the
 * first two fields of that struct.
 *
 * The use of these functions saves some code and makes sure the type
 * and the extension field of each struct are set correctly and reliably.
 * 
 * Usage without these helpers:
 *
 *     VkImageCreateInfo info;
 *     info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
 *     info.pNext = nullptr;
 *     info.flags = 0;
 *     info.imageType = VK_IMAGE_TYPE_2D;
 *     // ...
 *
 * Usage with these helpers:
 *
 *     auto info = kr::ImageCreateInfo();
 *     info.flags = 0;
 *     info.imageType = VK_IMAGE_TYPE_2D;
 *     // ...
 *
 * In the second example those first two lines of member initialization are saved.
 *
 * See `krust-examples/clear/clear.cpp` for more usage examples. 
 */
 ///@{

inline VkApplicationInfo ApplicationInfo()
{
  VkApplicationInfo info;
  info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkDeviceQueueCreateInfo DeviceQueueCreateInfo()
{
  VkDeviceQueueCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkDeviceCreateInfo DeviceCreateInfo()
{
  VkDeviceCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkInstanceCreateInfo InstanceCreateInfo()
{
  VkInstanceCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkMemoryAllocateInfo MemoryAllocateInfo()
{
  VkMemoryAllocateInfo info;
  info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkMappedMemoryRange MappedMemoryRange()
{
  VkMappedMemoryRange info;
  info.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
  info.pNext = nullptr;
  return info;
}

inline VkWriteDescriptorSet WriteDescriptorSet()
{
  VkWriteDescriptorSet info;
  info.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  info.pNext = nullptr;
  return info;
}

inline VkCopyDescriptorSet CopyDescriptorSet()
{
  VkCopyDescriptorSet info;
  info.sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
  info.pNext = nullptr;
  return info;
}

inline VkBufferCreateInfo BufferCreateInfo()
{
  VkBufferCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkBufferViewCreateInfo BufferViewCreateInfo()
{
  VkBufferViewCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkMemoryBarrier MemoryBarrier()
{
  VkMemoryBarrier info;
  info.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
  info.pNext = nullptr;
  return info;
}

inline VkBufferMemoryBarrier BufferMemoryBarrier()
{
  VkBufferMemoryBarrier info;
  info.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
  info.pNext = nullptr;
  return info;
}

inline VkImageMemoryBarrier ImageMemoryBarrier()
{
  VkImageMemoryBarrier info;
  info.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
  info.pNext = nullptr;
  return info;
}

inline VkImageCreateInfo ImageCreateInfo()
{
  VkImageCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkImageViewCreateInfo ImageViewCreateInfo()
{
  VkImageViewCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkBindSparseInfo BindSparseInfo()
{
  VkBindSparseInfo info;
  info.sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkShaderModuleCreateInfo ShaderModuleCreateInfo()
{
  VkShaderModuleCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkDescriptorSetLayoutCreateInfo DescriptorSetLayoutCreateInfo()
{
  VkDescriptorSetLayoutCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkDescriptorPoolCreateInfo DescriptorPoolCreateInfo()
{
  VkDescriptorPoolCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkDescriptorSetAllocateInfo DescriptorSetAllocateInfo()
{
  VkDescriptorSetAllocateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineShaderStageCreateInfo PipelineShaderStageCreateInfo()
{
  VkPipelineShaderStageCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkComputePipelineCreateInfo ComputePipelineCreateInfo()
{
  VkComputePipelineCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineVertexInputStateCreateInfo PipelineVertexInputStateCreateInfo()
{
  VkPipelineVertexInputStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineInputAssemblyStateCreateInfo PipelineInputAssemblyStateCreateInfo()
{
  VkPipelineInputAssemblyStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineTessellationStateCreateInfo PipelineTessellationStateCreateInfo()
{
  VkPipelineTessellationStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineViewportStateCreateInfo PipelineViewportStateCreateInfo()
{
  VkPipelineViewportStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineRasterizationStateCreateInfo PipelineRasterizationStateCreateInfo()
{
  VkPipelineRasterizationStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineMultisampleStateCreateInfo PipelineMultisampleStateCreateInfo()
{
  VkPipelineMultisampleStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineColorBlendStateCreateInfo PipelineColorBlendStateCreateInfo()
{
  VkPipelineColorBlendStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineDynamicStateCreateInfo PipelineDynamicStateCreateInfo()
{
  VkPipelineDynamicStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilStateCreateInfo()
{
  VkPipelineDepthStencilStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkGraphicsPipelineCreateInfo GraphicsPipelineCreateInfo()
{
  VkGraphicsPipelineCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineCacheCreateInfo PipelineCacheCreateInfo()
{
  VkPipelineCacheCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkPipelineLayoutCreateInfo PipelineLayoutCreateInfo()
{
  VkPipelineLayoutCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkSamplerCreateInfo SamplerCreateInfo()
{
  VkSamplerCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkCommandPoolCreateInfo CommandPoolCreateInfo()
{
  VkCommandPoolCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkCommandBufferAllocateInfo CommandBufferAllocateInfo()
{
  VkCommandBufferAllocateInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkCommandBufferInheritanceInfo CommandBufferInheritanceInfo()
{
  VkCommandBufferInheritanceInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkCommandBufferBeginInfo CommandBufferBeginInfo()
{
  VkCommandBufferBeginInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkRenderPassBeginInfo RenderPassBeginInfo()
{
  VkRenderPassBeginInfo info;
  info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkRenderPassCreateInfo RenderPassCreateInfo()
{
  VkRenderPassCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkEventCreateInfo EventCreateInfo()
{
  VkEventCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkFenceCreateInfo FenceCreateInfo()
{
  VkFenceCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkSemaphoreCreateInfo SemaphoreCreateInfo()
{
  VkSemaphoreCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkQueryPoolCreateInfo QueryPoolCreateInfo()
{
  VkQueryPoolCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkFramebufferCreateInfo FramebufferCreateInfo()
{
  VkFramebufferCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkSubmitInfo SubmitInfo()
{
  VkSubmitInfo info;
  info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
  info.pNext = nullptr;
  return info;
}

inline VkDisplayModeCreateInfoKHR DisplayModeCreateInfoKHR()
{
  VkDisplayModeCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  return info;
}

inline VkDisplaySurfaceCreateInfoKHR DisplaySurfaceCreateInfoKHR()
{
  VkDisplaySurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  return info;
}

inline VkDisplayPresentInfoKHR DisplayPresentInfoKHR()
{
  VkDisplayPresentInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
  info.pNext = nullptr;
  return info;
}

#ifdef VK_USE_PLATFORM_ANDROID_KHR
inline VkAndroidSurfaceCreateInfoKHR AndroidSurfaceCreateInfoKHR()
{
  VkAndroidSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  return info;
}
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR
inline VkMirSurfaceCreateInfoKHR MirSurfaceCreateInfoKHR()
{
  VkMirSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  return info;
}
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
inline VkWaylandSurfaceCreateInfoKHR WaylandSurfaceCreateInfoKHR()
{
  VkWaylandSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  return info;
}
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
inline VkWin32SurfaceCreateInfoKHR Win32SurfaceCreateInfoKHR()
{
  VkWin32SurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  return info;
}
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
inline VkXlibSurfaceCreateInfoKHR XlibSurfaceCreateInfoKHR()
{
  VkXlibSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  return info;
}
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
inline VkXcbSurfaceCreateInfoKHR XcbSurfaceCreateInfoKHR()
{
  VkXcbSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  return info;
}
#endif

inline VkSwapchainCreateInfoKHR SwapchainCreateInfoKHR()
{
  VkSwapchainCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
  info.pNext = nullptr;
  return info;
}

inline VkPresentInfoKHR PresentInfoKHR()
{
  VkPresentInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
  info.pNext = nullptr;
  return info;
}

inline VkDebugReportCallbackCreateInfoEXT DebugReportCallbackCreateInfoEXT()
{
  VkDebugReportCallbackCreateInfoEXT info;
  info.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT;
  info.pNext = nullptr;
  return info;
}

///@}

/**
 * @name VulkanTaggedStructParamsInit For each Vulkan API struct tagged with a
 * type enum and possessing an extension pointer, a function to initialize the
 * members of the struct without having to set the first two fields.
 *
 * The use of these functions saves some code and makes sure the type
 * and the extension field of each struct are set correctly and reliably.
 * It also ensures no member is forgotten by the user.
 * 
 * Usage without these helpers:
 *
 *     VkImageCreateInfo info;
 *     info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
 *     info.pNext = nullptr;
 *     info.flags = 0;
 *     info.imageType = VK_IMAGE_TYPE_2D;
 *     // ...
 *
 * Usage with these helpers:
 *
 *     auto info = kr::ImageCreateInfo(
 *       0,
 *       VK_IMAGE_TYPE_2D;
 *       // ...
 *     );
 *
 * See `krust-examples/clear2/clear2.cpp` for more usage examples. 
 */
 ///@{

inline VkApplicationInfo ApplicationInfo(
  const char * pApplicationName,
  uint32_t applicationVersion,
  const char * pEngineName,
  uint32_t engineVersion,
  uint32_t apiVersion
)
{
  VkApplicationInfo info;
  info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
  info.pNext = nullptr;
  info.pApplicationName = pApplicationName;
  info.applicationVersion = applicationVersion;
  info.pEngineName = pEngineName;
  info.engineVersion = engineVersion;
  info.apiVersion = apiVersion;

  return info;
}

inline VkDeviceQueueCreateInfo DeviceQueueCreateInfo(
  VkDeviceQueueCreateFlags flags,
  uint32_t queueFamilyIndex,
  uint32_t queueCount,
  const float * pQueuePriorities
)
{
  VkDeviceQueueCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.queueFamilyIndex = queueFamilyIndex;
  info.queueCount = queueCount;
  info.pQueuePriorities = pQueuePriorities;

  return info;
}

inline VkDeviceCreateInfo DeviceCreateInfo(
  VkDeviceCreateFlags flags,
  uint32_t queueCreateInfoCount,
  const VkDeviceQueueCreateInfo * pQueueCreateInfos,
  uint32_t enabledLayerCount,
  const char * const * ppEnabledLayerNames,
  uint32_t enabledExtensionCount,
  const char * const * ppEnabledExtensionNames,
  const VkPhysicalDeviceFeatures * pEnabledFeatures
)
{
  VkDeviceCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.queueCreateInfoCount = queueCreateInfoCount;
  info.pQueueCreateInfos = pQueueCreateInfos;
  info.enabledLayerCount = enabledLayerCount;
  info.ppEnabledLayerNames = ppEnabledLayerNames;
  info.enabledExtensionCount = enabledExtensionCount;
  info.ppEnabledExtensionNames = ppEnabledExtensionNames;
  info.pEnabledFeatures = pEnabledFeatures;

  return info;
}

inline VkInstanceCreateInfo InstanceCreateInfo(
  VkInstanceCreateFlags flags,
  const VkApplicationInfo * pApplicationInfo,
  uint32_t enabledLayerCount,
  const char * const * ppEnabledLayerNames,
  uint32_t enabledExtensionCount,
  const char * const * ppEnabledExtensionNames
)
{
  VkInstanceCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.pApplicationInfo = pApplicationInfo;
  info.enabledLayerCount = enabledLayerCount;
  info.ppEnabledLayerNames = ppEnabledLayerNames;
  info.enabledExtensionCount = enabledExtensionCount;
  info.ppEnabledExtensionNames = ppEnabledExtensionNames;

  return info;
}

inline VkMemoryAllocateInfo MemoryAllocateInfo(
  VkDeviceSize allocationSize,
  uint32_t memoryTypeIndex
)
{
  VkMemoryAllocateInfo info;
  info.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
  info.pNext = nullptr;
  info.allocationSize = allocationSize;
  info.memoryTypeIndex = memoryTypeIndex;

  return info;
}

inline VkMappedMemoryRange MappedMemoryRange(
  VkDeviceMemory memory,
  VkDeviceSize offset,
  VkDeviceSize size
)
{
  VkMappedMemoryRange info;
  info.sType = VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE;
  info.pNext = nullptr;
  info.memory = memory;
  info.offset = offset;
  info.size = size;

  return info;
}

inline VkWriteDescriptorSet WriteDescriptorSet(
  VkDescriptorSet dstSet,
  uint32_t dstBinding,
  uint32_t dstArrayElement,
  uint32_t descriptorCount,
  VkDescriptorType descriptorType,
  const VkDescriptorImageInfo * pImageInfo,
  const VkDescriptorBufferInfo * pBufferInfo,
  const VkBufferView * pTexelBufferView
)
{
  VkWriteDescriptorSet info;
  info.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
  info.pNext = nullptr;
  info.dstSet = dstSet;
  info.dstBinding = dstBinding;
  info.dstArrayElement = dstArrayElement;
  info.descriptorCount = descriptorCount;
  info.descriptorType = descriptorType;
  info.pImageInfo = pImageInfo;
  info.pBufferInfo = pBufferInfo;
  info.pTexelBufferView = pTexelBufferView;

  return info;
}

inline VkCopyDescriptorSet CopyDescriptorSet(
  VkDescriptorSet srcSet,
  uint32_t srcBinding,
  uint32_t srcArrayElement,
  VkDescriptorSet dstSet,
  uint32_t dstBinding,
  uint32_t dstArrayElement,
  uint32_t descriptorCount
)
{
  VkCopyDescriptorSet info;
  info.sType = VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET;
  info.pNext = nullptr;
  info.srcSet = srcSet;
  info.srcBinding = srcBinding;
  info.srcArrayElement = srcArrayElement;
  info.dstSet = dstSet;
  info.dstBinding = dstBinding;
  info.dstArrayElement = dstArrayElement;
  info.descriptorCount = descriptorCount;

  return info;
}

inline VkBufferCreateInfo BufferCreateInfo(
  VkBufferCreateFlags flags,
  VkDeviceSize size,
  VkBufferUsageFlags usage,
  VkSharingMode sharingMode,
  uint32_t queueFamilyIndexCount,
  const uint32_t * pQueueFamilyIndices
)
{
  VkBufferCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.size = size;
  info.usage = usage;
  info.sharingMode = sharingMode;
  info.queueFamilyIndexCount = queueFamilyIndexCount;
  info.pQueueFamilyIndices = pQueueFamilyIndices;

  return info;
}

inline VkBufferViewCreateInfo BufferViewCreateInfo(
  VkBufferViewCreateFlags flags,
  VkBuffer buffer,
  VkFormat format,
  VkDeviceSize offset,
  VkDeviceSize range
)
{
  VkBufferViewCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.buffer = buffer;
  info.format = format;
  info.offset = offset;
  info.range = range;

  return info;
}

inline VkMemoryBarrier MemoryBarrier(
  VkAccessFlags srcAccessMask,
  VkAccessFlags dstAccessMask
)
{
  VkMemoryBarrier info;
  info.sType = VK_STRUCTURE_TYPE_MEMORY_BARRIER;
  info.pNext = nullptr;
  info.srcAccessMask = srcAccessMask;
  info.dstAccessMask = dstAccessMask;

  return info;
}

inline VkBufferMemoryBarrier BufferMemoryBarrier(
  VkAccessFlags srcAccessMask,
  VkAccessFlags dstAccessMask,
  uint32_t srcQueueFamilyIndex,
  uint32_t dstQueueFamilyIndex,
  VkBuffer buffer,
  VkDeviceSize offset,
  VkDeviceSize size
)
{
  VkBufferMemoryBarrier info;
  info.sType = VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER;
  info.pNext = nullptr;
  info.srcAccessMask = srcAccessMask;
  info.dstAccessMask = dstAccessMask;
  info.srcQueueFamilyIndex = srcQueueFamilyIndex;
  info.dstQueueFamilyIndex = dstQueueFamilyIndex;
  info.buffer = buffer;
  info.offset = offset;
  info.size = size;

  return info;
}

inline VkImageMemoryBarrier ImageMemoryBarrier(
  VkAccessFlags srcAccessMask,
  VkAccessFlags dstAccessMask,
  VkImageLayout oldLayout,
  VkImageLayout newLayout,
  uint32_t srcQueueFamilyIndex,
  uint32_t dstQueueFamilyIndex,
  VkImage image,
  VkImageSubresourceRange subresourceRange
)
{
  VkImageMemoryBarrier info;
  info.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
  info.pNext = nullptr;
  info.srcAccessMask = srcAccessMask;
  info.dstAccessMask = dstAccessMask;
  info.oldLayout = oldLayout;
  info.newLayout = newLayout;
  info.srcQueueFamilyIndex = srcQueueFamilyIndex;
  info.dstQueueFamilyIndex = dstQueueFamilyIndex;
  info.image = image;
  info.subresourceRange = subresourceRange;

  return info;
}

inline VkImageCreateInfo ImageCreateInfo(
  VkImageCreateFlags flags,
  VkImageType imageType,
  VkFormat format,
  VkExtent3D extent,
  uint32_t mipLevels,
  uint32_t arrayLayers,
  VkSampleCountFlagBits samples,
  VkImageTiling tiling,
  VkImageUsageFlags usage,
  VkSharingMode sharingMode,
  uint32_t queueFamilyIndexCount,
  const uint32_t * pQueueFamilyIndices,
  VkImageLayout initialLayout
)
{
  VkImageCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.imageType = imageType;
  info.format = format;
  info.extent = extent;
  info.mipLevels = mipLevels;
  info.arrayLayers = arrayLayers;
  info.samples = samples;
  info.tiling = tiling;
  info.usage = usage;
  info.sharingMode = sharingMode;
  info.queueFamilyIndexCount = queueFamilyIndexCount;
  info.pQueueFamilyIndices = pQueueFamilyIndices;
  info.initialLayout = initialLayout;

  return info;
}

inline VkImageViewCreateInfo ImageViewCreateInfo(
  VkImageViewCreateFlags flags,
  VkImage image,
  VkImageViewType viewType,
  VkFormat format,
  VkComponentMapping components,
  VkImageSubresourceRange subresourceRange
)
{
  VkImageViewCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.image = image;
  info.viewType = viewType;
  info.format = format;
  info.components = components;
  info.subresourceRange = subresourceRange;

  return info;
}

inline VkBindSparseInfo BindSparseInfo(
  uint32_t waitSemaphoreCount,
  const VkSemaphore * pWaitSemaphores,
  uint32_t bufferBindCount,
  const VkSparseBufferMemoryBindInfo * pBufferBinds,
  uint32_t imageOpaqueBindCount,
  const VkSparseImageOpaqueMemoryBindInfo * pImageOpaqueBinds,
  uint32_t imageBindCount,
  const VkSparseImageMemoryBindInfo * pImageBinds,
  uint32_t signalSemaphoreCount,
  const VkSemaphore * pSignalSemaphores
)
{
  VkBindSparseInfo info;
  info.sType = VK_STRUCTURE_TYPE_BIND_SPARSE_INFO;
  info.pNext = nullptr;
  info.waitSemaphoreCount = waitSemaphoreCount;
  info.pWaitSemaphores = pWaitSemaphores;
  info.bufferBindCount = bufferBindCount;
  info.pBufferBinds = pBufferBinds;
  info.imageOpaqueBindCount = imageOpaqueBindCount;
  info.pImageOpaqueBinds = pImageOpaqueBinds;
  info.imageBindCount = imageBindCount;
  info.pImageBinds = pImageBinds;
  info.signalSemaphoreCount = signalSemaphoreCount;
  info.pSignalSemaphores = pSignalSemaphores;

  return info;
}

inline VkShaderModuleCreateInfo ShaderModuleCreateInfo(
  VkShaderModuleCreateFlags flags,
  size_t codeSize,
  const uint32_t * pCode
)
{
  VkShaderModuleCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.codeSize = codeSize;
  info.pCode = pCode;

  return info;
}

inline VkDescriptorSetLayoutCreateInfo DescriptorSetLayoutCreateInfo(
  VkDescriptorSetLayoutCreateFlags flags,
  uint32_t bindingCount,
  const VkDescriptorSetLayoutBinding * pBindings
)
{
  VkDescriptorSetLayoutCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.bindingCount = bindingCount;
  info.pBindings = pBindings;

  return info;
}

inline VkDescriptorPoolCreateInfo DescriptorPoolCreateInfo(
  VkDescriptorPoolCreateFlags flags,
  uint32_t maxSets,
  uint32_t poolSizeCount,
  const VkDescriptorPoolSize * pPoolSizes
)
{
  VkDescriptorPoolCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.maxSets = maxSets;
  info.poolSizeCount = poolSizeCount;
  info.pPoolSizes = pPoolSizes;

  return info;
}

inline VkDescriptorSetAllocateInfo DescriptorSetAllocateInfo(
  VkDescriptorPool descriptorPool,
  uint32_t descriptorSetCount,
  const VkDescriptorSetLayout * pSetLayouts
)
{
  VkDescriptorSetAllocateInfo info;
  info.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
  info.pNext = nullptr;
  info.descriptorPool = descriptorPool;
  info.descriptorSetCount = descriptorSetCount;
  info.pSetLayouts = pSetLayouts;

  return info;
}

inline VkPipelineShaderStageCreateInfo PipelineShaderStageCreateInfo(
  VkPipelineShaderStageCreateFlags flags,
  VkShaderStageFlagBits stage,
  VkShaderModule module,
  const char * pName,
  const VkSpecializationInfo * pSpecializationInfo
)
{
  VkPipelineShaderStageCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.stage = stage;
  info.module = module;
  info.pName = pName;
  info.pSpecializationInfo = pSpecializationInfo;

  return info;
}

inline VkComputePipelineCreateInfo ComputePipelineCreateInfo(
  VkPipelineCreateFlags flags,
  VkPipelineShaderStageCreateInfo stage,
  VkPipelineLayout layout,
  VkPipeline basePipelineHandle,
  int32_t basePipelineIndex
)
{
  VkComputePipelineCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.stage = stage;
  info.layout = layout;
  info.basePipelineHandle = basePipelineHandle;
  info.basePipelineIndex = basePipelineIndex;

  return info;
}

inline VkPipelineVertexInputStateCreateInfo PipelineVertexInputStateCreateInfo(
  VkPipelineVertexInputStateCreateFlags flags,
  uint32_t vertexBindingDescriptionCount,
  const VkVertexInputBindingDescription * pVertexBindingDescriptions,
  uint32_t vertexAttributeDescriptionCount,
  const VkVertexInputAttributeDescription * pVertexAttributeDescriptions
)
{
  VkPipelineVertexInputStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.vertexBindingDescriptionCount = vertexBindingDescriptionCount;
  info.pVertexBindingDescriptions = pVertexBindingDescriptions;
  info.vertexAttributeDescriptionCount = vertexAttributeDescriptionCount;
  info.pVertexAttributeDescriptions = pVertexAttributeDescriptions;

  return info;
}

inline VkPipelineInputAssemblyStateCreateInfo PipelineInputAssemblyStateCreateInfo(
  VkPipelineInputAssemblyStateCreateFlags flags,
  VkPrimitiveTopology topology,
  VkBool32 primitiveRestartEnable
)
{
  VkPipelineInputAssemblyStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.topology = topology;
  info.primitiveRestartEnable = primitiveRestartEnable;

  return info;
}

inline VkPipelineTessellationStateCreateInfo PipelineTessellationStateCreateInfo(
  VkPipelineTessellationStateCreateFlags flags,
  uint32_t patchControlPoints
)
{
  VkPipelineTessellationStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.patchControlPoints = patchControlPoints;

  return info;
}

inline VkPipelineViewportStateCreateInfo PipelineViewportStateCreateInfo(
  VkPipelineViewportStateCreateFlags flags,
  uint32_t viewportCount,
  const VkViewport * pViewports,
  uint32_t scissorCount,
  const VkRect2D * pScissors
)
{
  VkPipelineViewportStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.viewportCount = viewportCount;
  info.pViewports = pViewports;
  info.scissorCount = scissorCount;
  info.pScissors = pScissors;

  return info;
}

inline VkPipelineRasterizationStateCreateInfo PipelineRasterizationStateCreateInfo(
  VkPipelineRasterizationStateCreateFlags flags,
  VkBool32 depthClampEnable,
  VkBool32 rasterizerDiscardEnable,
  VkPolygonMode polygonMode,
  VkCullModeFlags cullMode,
  VkFrontFace frontFace,
  VkBool32 depthBiasEnable,
  float depthBiasConstantFactor,
  float depthBiasClamp,
  float depthBiasSlopeFactor,
  float lineWidth
)
{
  VkPipelineRasterizationStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.depthClampEnable = depthClampEnable;
  info.rasterizerDiscardEnable = rasterizerDiscardEnable;
  info.polygonMode = polygonMode;
  info.cullMode = cullMode;
  info.frontFace = frontFace;
  info.depthBiasEnable = depthBiasEnable;
  info.depthBiasConstantFactor = depthBiasConstantFactor;
  info.depthBiasClamp = depthBiasClamp;
  info.depthBiasSlopeFactor = depthBiasSlopeFactor;
  info.lineWidth = lineWidth;

  return info;
}

inline VkPipelineMultisampleStateCreateInfo PipelineMultisampleStateCreateInfo(
  VkPipelineMultisampleStateCreateFlags flags,
  VkSampleCountFlagBits rasterizationSamples,
  VkBool32 sampleShadingEnable,
  float minSampleShading,
  const VkSampleMask * pSampleMask,
  VkBool32 alphaToCoverageEnable,
  VkBool32 alphaToOneEnable
)
{
  VkPipelineMultisampleStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.rasterizationSamples = rasterizationSamples;
  info.sampleShadingEnable = sampleShadingEnable;
  info.minSampleShading = minSampleShading;
  info.pSampleMask = pSampleMask;
  info.alphaToCoverageEnable = alphaToCoverageEnable;
  info.alphaToOneEnable = alphaToOneEnable;

  return info;
}

inline VkPipelineColorBlendStateCreateInfo PipelineColorBlendStateCreateInfo(
  VkPipelineColorBlendStateCreateFlags flags,
  VkBool32 logicOpEnable,
  VkLogicOp logicOp,
  uint32_t attachmentCount,
  const VkPipelineColorBlendAttachmentState * pAttachments,
  float blendConstants[4]
)
{
  VkPipelineColorBlendStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.logicOpEnable = logicOpEnable;
  info.logicOp = logicOp;
  info.attachmentCount = attachmentCount;
  info.pAttachments = pAttachments;
  info.blendConstants[0] = blendConstants[0];
  info.blendConstants[1] = blendConstants[1];
  info.blendConstants[2] = blendConstants[2];
  info.blendConstants[3] = blendConstants[3];

  return info;
}

inline VkPipelineDynamicStateCreateInfo PipelineDynamicStateCreateInfo(
  VkPipelineDynamicStateCreateFlags flags,
  uint32_t dynamicStateCount,
  const VkDynamicState * pDynamicStates
)
{
  VkPipelineDynamicStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.dynamicStateCount = dynamicStateCount;
  info.pDynamicStates = pDynamicStates;

  return info;
}

inline VkPipelineDepthStencilStateCreateInfo PipelineDepthStencilStateCreateInfo(
  VkPipelineDepthStencilStateCreateFlags flags,
  VkBool32 depthTestEnable,
  VkBool32 depthWriteEnable,
  VkCompareOp depthCompareOp,
  VkBool32 depthBoundsTestEnable,
  VkBool32 stencilTestEnable,
  VkStencilOpState front,
  VkStencilOpState back,
  float minDepthBounds,
  float maxDepthBounds
)
{
  VkPipelineDepthStencilStateCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.depthTestEnable = depthTestEnable;
  info.depthWriteEnable = depthWriteEnable;
  info.depthCompareOp = depthCompareOp;
  info.depthBoundsTestEnable = depthBoundsTestEnable;
  info.stencilTestEnable = stencilTestEnable;
  info.front = front;
  info.back = back;
  info.minDepthBounds = minDepthBounds;
  info.maxDepthBounds = maxDepthBounds;

  return info;
}

inline VkGraphicsPipelineCreateInfo GraphicsPipelineCreateInfo(
  VkPipelineCreateFlags flags,
  uint32_t stageCount,
  const VkPipelineShaderStageCreateInfo * pStages,
  const VkPipelineVertexInputStateCreateInfo * pVertexInputState,
  const VkPipelineInputAssemblyStateCreateInfo * pInputAssemblyState,
  const VkPipelineTessellationStateCreateInfo * pTessellationState,
  const VkPipelineViewportStateCreateInfo * pViewportState,
  const VkPipelineRasterizationStateCreateInfo * pRasterizationState,
  const VkPipelineMultisampleStateCreateInfo * pMultisampleState,
  const VkPipelineDepthStencilStateCreateInfo * pDepthStencilState,
  const VkPipelineColorBlendStateCreateInfo * pColorBlendState,
  const VkPipelineDynamicStateCreateInfo * pDynamicState,
  VkPipelineLayout layout,
  VkRenderPass renderPass,
  uint32_t subpass,
  VkPipeline basePipelineHandle,
  int32_t basePipelineIndex
)
{
  VkGraphicsPipelineCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.stageCount = stageCount;
  info.pStages = pStages;
  info.pVertexInputState = pVertexInputState;
  info.pInputAssemblyState = pInputAssemblyState;
  info.pTessellationState = pTessellationState;
  info.pViewportState = pViewportState;
  info.pRasterizationState = pRasterizationState;
  info.pMultisampleState = pMultisampleState;
  info.pDepthStencilState = pDepthStencilState;
  info.pColorBlendState = pColorBlendState;
  info.pDynamicState = pDynamicState;
  info.layout = layout;
  info.renderPass = renderPass;
  info.subpass = subpass;
  info.basePipelineHandle = basePipelineHandle;
  info.basePipelineIndex = basePipelineIndex;

  return info;
}

inline VkPipelineCacheCreateInfo PipelineCacheCreateInfo(
  VkPipelineCacheCreateFlags flags,
  size_t initialDataSize,
  const void * pInitialData
)
{
  VkPipelineCacheCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.initialDataSize = initialDataSize;
  info.pInitialData = pInitialData;

  return info;
}

inline VkPipelineLayoutCreateInfo PipelineLayoutCreateInfo(
  VkPipelineLayoutCreateFlags flags,
  uint32_t setLayoutCount,
  const VkDescriptorSetLayout * pSetLayouts,
  uint32_t pushConstantRangeCount,
  const VkPushConstantRange * pPushConstantRanges
)
{
  VkPipelineLayoutCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.setLayoutCount = setLayoutCount;
  info.pSetLayouts = pSetLayouts;
  info.pushConstantRangeCount = pushConstantRangeCount;
  info.pPushConstantRanges = pPushConstantRanges;

  return info;
}

inline VkSamplerCreateInfo SamplerCreateInfo(
  VkSamplerCreateFlags flags,
  VkFilter magFilter,
  VkFilter minFilter,
  VkSamplerMipmapMode mipmapMode,
  VkSamplerAddressMode addressModeU,
  VkSamplerAddressMode addressModeV,
  VkSamplerAddressMode addressModeW,
  float mipLodBias,
  VkBool32 anisotropyEnable,
  float maxAnisotropy,
  VkBool32 compareEnable,
  VkCompareOp compareOp,
  float minLod,
  float maxLod,
  VkBorderColor borderColor,
  VkBool32 unnormalizedCoordinates
)
{
  VkSamplerCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.magFilter = magFilter;
  info.minFilter = minFilter;
  info.mipmapMode = mipmapMode;
  info.addressModeU = addressModeU;
  info.addressModeV = addressModeV;
  info.addressModeW = addressModeW;
  info.mipLodBias = mipLodBias;
  info.anisotropyEnable = anisotropyEnable;
  info.maxAnisotropy = maxAnisotropy;
  info.compareEnable = compareEnable;
  info.compareOp = compareOp;
  info.minLod = minLod;
  info.maxLod = maxLod;
  info.borderColor = borderColor;
  info.unnormalizedCoordinates = unnormalizedCoordinates;

  return info;
}

inline VkCommandPoolCreateInfo CommandPoolCreateInfo(
  VkCommandPoolCreateFlags flags,
  uint32_t queueFamilyIndex
)
{
  VkCommandPoolCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.queueFamilyIndex = queueFamilyIndex;

  return info;
}

inline VkCommandBufferAllocateInfo CommandBufferAllocateInfo(
  VkCommandPool commandPool,
  VkCommandBufferLevel level,
  uint32_t commandBufferCount
)
{
  VkCommandBufferAllocateInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
  info.pNext = nullptr;
  info.commandPool = commandPool;
  info.level = level;
  info.commandBufferCount = commandBufferCount;

  return info;
}

inline VkCommandBufferInheritanceInfo CommandBufferInheritanceInfo(
  VkRenderPass renderPass,
  uint32_t subpass,
  VkFramebuffer framebuffer,
  VkBool32 occlusionQueryEnable,
  VkQueryControlFlags queryFlags,
  VkQueryPipelineStatisticFlags pipelineStatistics
)
{
  VkCommandBufferInheritanceInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO;
  info.pNext = nullptr;
  info.renderPass = renderPass;
  info.subpass = subpass;
  info.framebuffer = framebuffer;
  info.occlusionQueryEnable = occlusionQueryEnable;
  info.queryFlags = queryFlags;
  info.pipelineStatistics = pipelineStatistics;

  return info;
}

inline VkCommandBufferBeginInfo CommandBufferBeginInfo(
  VkCommandBufferUsageFlags flags,
  const VkCommandBufferInheritanceInfo * pInheritanceInfo
)
{
  VkCommandBufferBeginInfo info;
  info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.pInheritanceInfo = pInheritanceInfo;

  return info;
}

inline VkRenderPassBeginInfo RenderPassBeginInfo(
  VkRenderPass renderPass,
  VkFramebuffer framebuffer,
  VkRect2D renderArea,
  uint32_t clearValueCount,
  const VkClearValue * pClearValues
)
{
  VkRenderPassBeginInfo info;
  info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
  info.pNext = nullptr;
  info.renderPass = renderPass;
  info.framebuffer = framebuffer;
  info.renderArea = renderArea;
  info.clearValueCount = clearValueCount;
  info.pClearValues = pClearValues;

  return info;
}

inline VkRenderPassCreateInfo RenderPassCreateInfo(
  VkRenderPassCreateFlags flags,
  uint32_t attachmentCount,
  const VkAttachmentDescription * pAttachments,
  uint32_t subpassCount,
  const VkSubpassDescription * pSubpasses,
  uint32_t dependencyCount,
  const VkSubpassDependency * pDependencies
)
{
  VkRenderPassCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.attachmentCount = attachmentCount;
  info.pAttachments = pAttachments;
  info.subpassCount = subpassCount;
  info.pSubpasses = pSubpasses;
  info.dependencyCount = dependencyCount;
  info.pDependencies = pDependencies;

  return info;
}

inline VkEventCreateInfo EventCreateInfo(
  VkEventCreateFlags flags
)
{
  VkEventCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_EVENT_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;

  return info;
}

inline VkFenceCreateInfo FenceCreateInfo(
  VkFenceCreateFlags flags
)
{
  VkFenceCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;

  return info;
}

inline VkSemaphoreCreateInfo SemaphoreCreateInfo(
  VkSemaphoreCreateFlags flags
)
{
  VkSemaphoreCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;

  return info;
}

inline VkQueryPoolCreateInfo QueryPoolCreateInfo(
  VkQueryPoolCreateFlags flags,
  VkQueryType queryType,
  uint32_t queryCount,
  VkQueryPipelineStatisticFlags pipelineStatistics
)
{
  VkQueryPoolCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.queryType = queryType;
  info.queryCount = queryCount;
  info.pipelineStatistics = pipelineStatistics;

  return info;
}

inline VkFramebufferCreateInfo FramebufferCreateInfo(
  VkFramebufferCreateFlags flags,
  VkRenderPass renderPass,
  uint32_t attachmentCount,
  const VkImageView * pAttachments,
  uint32_t width,
  uint32_t height,
  uint32_t layers
)
{
  VkFramebufferCreateInfo info;
  info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
  info.pNext = nullptr;
  info.flags = flags;
  info.renderPass = renderPass;
  info.attachmentCount = attachmentCount;
  info.pAttachments = pAttachments;
  info.width = width;
  info.height = height;
  info.layers = layers;

  return info;
}

inline VkSubmitInfo SubmitInfo(
  uint32_t waitSemaphoreCount,
  const VkSemaphore * pWaitSemaphores,
  const VkPipelineStageFlags * pWaitDstStageMask,
  uint32_t commandBufferCount,
  const VkCommandBuffer * pCommandBuffers,
  uint32_t signalSemaphoreCount,
  const VkSemaphore * pSignalSemaphores
)
{
  VkSubmitInfo info;
  info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
  info.pNext = nullptr;
  info.waitSemaphoreCount = waitSemaphoreCount;
  info.pWaitSemaphores = pWaitSemaphores;
  info.pWaitDstStageMask = pWaitDstStageMask;
  info.commandBufferCount = commandBufferCount;
  info.pCommandBuffers = pCommandBuffers;
  info.signalSemaphoreCount = signalSemaphoreCount;
  info.pSignalSemaphores = pSignalSemaphores;

  return info;
}

inline VkDisplayModeCreateInfoKHR DisplayModeCreateInfoKHR(
  VkDisplayModeCreateFlagsKHR flags,
  VkDisplayModeParametersKHR parameters
)
{
  VkDisplayModeCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  info.flags = flags;
  info.parameters = parameters;

  return info;
}

inline VkDisplaySurfaceCreateInfoKHR DisplaySurfaceCreateInfoKHR(
  VkDisplaySurfaceCreateFlagsKHR flags,
  VkDisplayModeKHR displayMode,
  uint32_t planeIndex,
  uint32_t planeStackIndex,
  VkSurfaceTransformFlagBitsKHR transform,
  float globalAlpha,
  VkDisplayPlaneAlphaFlagBitsKHR alphaMode,
  VkExtent2D imageExtent
)
{
  VkDisplaySurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  info.flags = flags;
  info.displayMode = displayMode;
  info.planeIndex = planeIndex;
  info.planeStackIndex = planeStackIndex;
  info.transform = transform;
  info.globalAlpha = globalAlpha;
  info.alphaMode = alphaMode;
  info.imageExtent = imageExtent;

  return info;
}

inline VkDisplayPresentInfoKHR DisplayPresentInfoKHR(
  VkRect2D srcRect,
  VkRect2D dstRect,
  VkBool32 persistent
)
{
  VkDisplayPresentInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR;
  info.pNext = nullptr;
  info.srcRect = srcRect;
  info.dstRect = dstRect;
  info.persistent = persistent;

  return info;
}

#ifdef VK_USE_PLATFORM_ANDROID_KHR
inline VkAndroidSurfaceCreateInfoKHR AndroidSurfaceCreateInfoKHR(
  VkAndroidSurfaceCreateFlagsKHR flags,
  ANativeWindow window
)
{
  VkAndroidSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  info.flags = flags;
  info.window = window;

  return info;
}
#endif

#ifdef VK_USE_PLATFORM_MIR_KHR
inline VkMirSurfaceCreateInfoKHR MirSurfaceCreateInfoKHR(
  VkMirSurfaceCreateFlagsKHR flags,
  MirConnection connection,
  MirSurface mirSurface
)
{
  VkMirSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  info.flags = flags;
  info.connection = connection;
  info.mirSurface = mirSurface;

  return info;
}
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
inline VkWaylandSurfaceCreateInfoKHR WaylandSurfaceCreateInfoKHR(
  VkWaylandSurfaceCreateFlagsKHR flags,
  wl_display display,
  wl_surface surface
)
{
  VkWaylandSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  info.flags = flags;
  info.display = display;
  info.surface = surface;

  return info;
}
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
inline VkWin32SurfaceCreateInfoKHR Win32SurfaceCreateInfoKHR(
  VkWin32SurfaceCreateFlagsKHR flags,
  HINSTANCE hinstance,
  HWND hwnd
)
{
  VkWin32SurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  info.flags = flags;
  info.hinstance = hinstance;
  info.hwnd = hwnd;

  return info;
}
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
inline VkXlibSurfaceCreateInfoKHR XlibSurfaceCreateInfoKHR(
  VkXlibSurfaceCreateFlagsKHR flags,
  Display dpy,
  Window window
)
{
  VkXlibSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  info.flags = flags;
  info.dpy = dpy;
  info.window = window;

  return info;
}
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
inline VkXcbSurfaceCreateInfoKHR XcbSurfaceCreateInfoKHR(
  VkXcbSurfaceCreateFlagsKHR flags,
  xcb_connection_t connection,
  xcb_window_t window
)
{
  VkXcbSurfaceCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
  info.pNext = nullptr;
  info.flags = flags;
  info.connection = connection;
  info.window = window;

  return info;
}
#endif

inline VkSwapchainCreateInfoKHR SwapchainCreateInfoKHR(
  VkSwapchainCreateFlagsKHR flags,
  VkSurfaceKHR surface,
  uint32_t minImageCount,
  VkFormat imageFormat,
  VkColorSpaceKHR imageColorSpace,
  VkExtent2D imageExtent,
  uint32_t imageArrayLayers,
  VkImageUsageFlags imageUsage,
  VkSharingMode imageSharingMode,
  uint32_t queueFamilyIndexCount,
  const uint32_t * pQueueFamilyIndices,
  VkSurfaceTransformFlagBitsKHR preTransform,
  VkCompositeAlphaFlagBitsKHR compositeAlpha,
  VkPresentModeKHR presentMode,
  VkBool32 clipped,
  VkSwapchainKHR oldSwapchain
)
{
  VkSwapchainCreateInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
  info.pNext = nullptr;
  info.flags = flags;
  info.surface = surface;
  info.minImageCount = minImageCount;
  info.imageFormat = imageFormat;
  info.imageColorSpace = imageColorSpace;
  info.imageExtent = imageExtent;
  info.imageArrayLayers = imageArrayLayers;
  info.imageUsage = imageUsage;
  info.imageSharingMode = imageSharingMode;
  info.queueFamilyIndexCount = queueFamilyIndexCount;
  info.pQueueFamilyIndices = pQueueFamilyIndices;
  info.preTransform = preTransform;
  info.compositeAlpha = compositeAlpha;
  info.presentMode = presentMode;
  info.clipped = clipped;
  info.oldSwapchain = oldSwapchain;

  return info;
}

inline VkPresentInfoKHR PresentInfoKHR(
  uint32_t waitSemaphoreCount,
  const VkSemaphore * pWaitSemaphores,
  uint32_t swapchainCount,
  const VkSwapchainKHR * pSwapchains,
  const uint32_t * pImageIndices,
  VkResult * pResults
)
{
  VkPresentInfoKHR info;
  info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
  info.pNext = nullptr;
  info.waitSemaphoreCount = waitSemaphoreCount;
  info.pWaitSemaphores = pWaitSemaphores;
  info.swapchainCount = swapchainCount;
  info.pSwapchains = pSwapchains;
  info.pImageIndices = pImageIndices;
  info.pResults = pResults;

  return info;
}

inline VkDebugReportCallbackCreateInfoEXT DebugReportCallbackCreateInfoEXT(
  VkDebugReportFlagsEXT flags,
  PFN_vkDebugReportCallbackEXT pfnCallback,
  void * pUserData
)
{
  VkDebugReportCallbackCreateInfoEXT info;
  info.sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT;
  info.pNext = nullptr;
  info.flags = flags;
  info.pfnCallback = pfnCallback;
  info.pUserData = pUserData;

  return info;
}

///@}

/**
 * @name VulkanUntaggedStructParamsInit For each small Vulkan API struct,
 * a function to initialize the members of the struct.
 *
 * The use of these functions ensures no member is forgotten by the user.
 * 
 * Usage without these helpers:
 *
 *     VkOffset2D offset;
 *     offset.x = 64;
 *     offset.y = 128;
 *     
 * Usage with these helpers:
 *
 *     auto offset = kr::Offset2D(64, 128);
 *
 */
 ///@{

inline VkOffset2D Offset2D(
  int32_t x,
  int32_t y
)
{
  VkOffset2D temp;
  temp.x = x;
  temp.y = y;

  return temp;
}

inline VkOffset3D Offset3D(
  int32_t x,
  int32_t y,
  int32_t z
)
{
  VkOffset3D temp;
  temp.x = x;
  temp.y = y;
  temp.z = z;

  return temp;
}

inline VkExtent2D Extent2D(
  uint32_t width,
  uint32_t height
)
{
  VkExtent2D temp;
  temp.width = width;
  temp.height = height;

  return temp;
}

inline VkExtent3D Extent3D(
  uint32_t width,
  uint32_t height,
  uint32_t depth
)
{
  VkExtent3D temp;
  temp.width = width;
  temp.height = height;
  temp.depth = depth;

  return temp;
}

inline VkViewport Viewport(
  float x,
  float y,
  float width,
  float height,
  float minDepth,
  float maxDepth
)
{
  VkViewport temp;
  temp.x = x;
  temp.y = y;
  temp.width = width;
  temp.height = height;
  temp.minDepth = minDepth;
  temp.maxDepth = maxDepth;

  return temp;
}

inline VkRect2D Rect2D(
  VkOffset2D offset,
  VkExtent2D extent
)
{
  VkRect2D temp;
  temp.offset = offset;
  temp.extent = extent;

  return temp;
}

inline VkClearRect ClearRect(
  VkRect2D rect,
  uint32_t baseArrayLayer,
  uint32_t layerCount
)
{
  VkClearRect temp;
  temp.rect = rect;
  temp.baseArrayLayer = baseArrayLayer;
  temp.layerCount = layerCount;

  return temp;
}

inline VkComponentMapping ComponentMapping(
  VkComponentSwizzle r,
  VkComponentSwizzle g,
  VkComponentSwizzle b,
  VkComponentSwizzle a
)
{
  VkComponentMapping temp;
  temp.r = r;
  temp.g = g;
  temp.b = b;
  temp.a = a;

  return temp;
}

inline VkAllocationCallbacks AllocationCallbacks(
  void * pUserData,
  PFN_vkAllocationFunction pfnAllocation,
  PFN_vkReallocationFunction pfnReallocation,
  PFN_vkFreeFunction pfnFree,
  PFN_vkInternalAllocationNotification pfnInternalAllocation,
  PFN_vkInternalFreeNotification pfnInternalFree
)
{
  VkAllocationCallbacks temp;
  temp.pUserData = pUserData;
  temp.pfnAllocation = pfnAllocation;
  temp.pfnReallocation = pfnReallocation;
  temp.pfnFree = pfnFree;
  temp.pfnInternalAllocation = pfnInternalAllocation;
  temp.pfnInternalFree = pfnInternalFree;

  return temp;
}

inline VkQueueFamilyProperties QueueFamilyProperties(
  VkQueueFlags queueFlags,
  uint32_t queueCount,
  uint32_t timestampValidBits,
  VkExtent3D minImageTransferGranularity
)
{
  VkQueueFamilyProperties temp;
  temp.queueFlags = queueFlags;
  temp.queueCount = queueCount;
  temp.timestampValidBits = timestampValidBits;
  temp.minImageTransferGranularity = minImageTransferGranularity;

  return temp;
}

inline VkMemoryRequirements MemoryRequirements(
  VkDeviceSize size,
  VkDeviceSize alignment,
  uint32_t memoryTypeBits
)
{
  VkMemoryRequirements temp;
  temp.size = size;
  temp.alignment = alignment;
  temp.memoryTypeBits = memoryTypeBits;

  return temp;
}

inline VkSparseImageFormatProperties SparseImageFormatProperties(
  VkImageAspectFlags aspectMask,
  VkExtent3D imageGranularity,
  VkSparseImageFormatFlags flags
)
{
  VkSparseImageFormatProperties temp;
  temp.aspectMask = aspectMask;
  temp.imageGranularity = imageGranularity;
  temp.flags = flags;

  return temp;
}

inline VkSparseImageMemoryRequirements SparseImageMemoryRequirements(
  VkSparseImageFormatProperties formatProperties,
  uint32_t imageMipTailFirstLod,
  VkDeviceSize imageMipTailSize,
  VkDeviceSize imageMipTailOffset,
  VkDeviceSize imageMipTailStride
)
{
  VkSparseImageMemoryRequirements temp;
  temp.formatProperties = formatProperties;
  temp.imageMipTailFirstLod = imageMipTailFirstLod;
  temp.imageMipTailSize = imageMipTailSize;
  temp.imageMipTailOffset = imageMipTailOffset;
  temp.imageMipTailStride = imageMipTailStride;

  return temp;
}

inline VkMemoryType MemoryType(
  VkMemoryPropertyFlags propertyFlags,
  uint32_t heapIndex
)
{
  VkMemoryType temp;
  temp.propertyFlags = propertyFlags;
  temp.heapIndex = heapIndex;

  return temp;
}

inline VkMemoryHeap MemoryHeap(
  VkDeviceSize size,
  VkMemoryHeapFlags flags
)
{
  VkMemoryHeap temp;
  temp.size = size;
  temp.flags = flags;

  return temp;
}

inline VkFormatProperties FormatProperties(
  VkFormatFeatureFlags linearTilingFeatures,
  VkFormatFeatureFlags optimalTilingFeatures,
  VkFormatFeatureFlags bufferFeatures
)
{
  VkFormatProperties temp;
  temp.linearTilingFeatures = linearTilingFeatures;
  temp.optimalTilingFeatures = optimalTilingFeatures;
  temp.bufferFeatures = bufferFeatures;

  return temp;
}

inline VkImageFormatProperties ImageFormatProperties(
  VkExtent3D maxExtent,
  uint32_t maxMipLevels,
  uint32_t maxArrayLayers,
  VkSampleCountFlags sampleCounts,
  VkDeviceSize maxResourceSize
)
{
  VkImageFormatProperties temp;
  temp.maxExtent = maxExtent;
  temp.maxMipLevels = maxMipLevels;
  temp.maxArrayLayers = maxArrayLayers;
  temp.sampleCounts = sampleCounts;
  temp.maxResourceSize = maxResourceSize;

  return temp;
}

inline VkDescriptorBufferInfo DescriptorBufferInfo(
  VkBuffer buffer,
  VkDeviceSize offset,
  VkDeviceSize range
)
{
  VkDescriptorBufferInfo temp;
  temp.buffer = buffer;
  temp.offset = offset;
  temp.range = range;

  return temp;
}

inline VkDescriptorImageInfo DescriptorImageInfo(
  VkSampler sampler,
  VkImageView imageView,
  VkImageLayout imageLayout
)
{
  VkDescriptorImageInfo temp;
  temp.sampler = sampler;
  temp.imageView = imageView;
  temp.imageLayout = imageLayout;

  return temp;
}

inline VkImageSubresource ImageSubresource(
  VkImageAspectFlags aspectMask,
  uint32_t mipLevel,
  uint32_t arrayLayer
)
{
  VkImageSubresource temp;
  temp.aspectMask = aspectMask;
  temp.mipLevel = mipLevel;
  temp.arrayLayer = arrayLayer;

  return temp;
}

inline VkImageSubresourceLayers ImageSubresourceLayers(
  VkImageAspectFlags aspectMask,
  uint32_t mipLevel,
  uint32_t baseArrayLayer,
  uint32_t layerCount
)
{
  VkImageSubresourceLayers temp;
  temp.aspectMask = aspectMask;
  temp.mipLevel = mipLevel;
  temp.baseArrayLayer = baseArrayLayer;
  temp.layerCount = layerCount;

  return temp;
}

inline VkImageSubresourceRange ImageSubresourceRange(
  VkImageAspectFlags aspectMask,
  uint32_t baseMipLevel,
  uint32_t levelCount,
  uint32_t baseArrayLayer,
  uint32_t layerCount
)
{
  VkImageSubresourceRange temp;
  temp.aspectMask = aspectMask;
  temp.baseMipLevel = baseMipLevel;
  temp.levelCount = levelCount;
  temp.baseArrayLayer = baseArrayLayer;
  temp.layerCount = layerCount;

  return temp;
}

inline VkSubresourceLayout SubresourceLayout(
  VkDeviceSize offset,
  VkDeviceSize size,
  VkDeviceSize rowPitch,
  VkDeviceSize arrayPitch,
  VkDeviceSize depthPitch
)
{
  VkSubresourceLayout temp;
  temp.offset = offset;
  temp.size = size;
  temp.rowPitch = rowPitch;
  temp.arrayPitch = arrayPitch;
  temp.depthPitch = depthPitch;

  return temp;
}

inline VkBufferCopy BufferCopy(
  VkDeviceSize srcOffset,
  VkDeviceSize dstOffset,
  VkDeviceSize size
)
{
  VkBufferCopy temp;
  temp.srcOffset = srcOffset;
  temp.dstOffset = dstOffset;
  temp.size = size;

  return temp;
}

inline VkSparseMemoryBind SparseMemoryBind(
  VkDeviceSize resourceOffset,
  VkDeviceSize size,
  VkDeviceMemory memory,
  VkDeviceSize memoryOffset,
  VkSparseMemoryBindFlags flags
)
{
  VkSparseMemoryBind temp;
  temp.resourceOffset = resourceOffset;
  temp.size = size;
  temp.memory = memory;
  temp.memoryOffset = memoryOffset;
  temp.flags = flags;

  return temp;
}

inline VkSparseImageMemoryBind SparseImageMemoryBind(
  VkImageSubresource subresource,
  VkOffset3D offset,
  VkExtent3D extent,
  VkDeviceMemory memory,
  VkDeviceSize memoryOffset,
  VkSparseMemoryBindFlags flags
)
{
  VkSparseImageMemoryBind temp;
  temp.subresource = subresource;
  temp.offset = offset;
  temp.extent = extent;
  temp.memory = memory;
  temp.memoryOffset = memoryOffset;
  temp.flags = flags;

  return temp;
}

inline VkSparseBufferMemoryBindInfo SparseBufferMemoryBindInfo(
  VkBuffer buffer,
  uint32_t bindCount,
  const VkSparseMemoryBind * pBinds
)
{
  VkSparseBufferMemoryBindInfo temp;
  temp.buffer = buffer;
  temp.bindCount = bindCount;
  temp.pBinds = pBinds;

  return temp;
}

inline VkSparseImageOpaqueMemoryBindInfo SparseImageOpaqueMemoryBindInfo(
  VkImage image,
  uint32_t bindCount,
  const VkSparseMemoryBind * pBinds
)
{
  VkSparseImageOpaqueMemoryBindInfo temp;
  temp.image = image;
  temp.bindCount = bindCount;
  temp.pBinds = pBinds;

  return temp;
}

inline VkSparseImageMemoryBindInfo SparseImageMemoryBindInfo(
  VkImage image,
  uint32_t bindCount,
  const VkSparseImageMemoryBind * pBinds
)
{
  VkSparseImageMemoryBindInfo temp;
  temp.image = image;
  temp.bindCount = bindCount;
  temp.pBinds = pBinds;

  return temp;
}

inline VkImageCopy ImageCopy(
  VkImageSubresourceLayers srcSubresource,
  VkOffset3D srcOffset,
  VkImageSubresourceLayers dstSubresource,
  VkOffset3D dstOffset,
  VkExtent3D extent
)
{
  VkImageCopy temp;
  temp.srcSubresource = srcSubresource;
  temp.srcOffset = srcOffset;
  temp.dstSubresource = dstSubresource;
  temp.dstOffset = dstOffset;
  temp.extent = extent;

  return temp;
}

inline VkImageBlit ImageBlit(
  VkImageSubresourceLayers srcSubresource,
  VkOffset3D srcOffsets[2],
  VkImageSubresourceLayers dstSubresource,
  VkOffset3D dstOffsets[2]
)
{
  VkImageBlit temp;
  temp.srcSubresource = srcSubresource;
  temp.srcOffsets[2] = srcOffsets[2];
  temp.dstSubresource = dstSubresource;
  temp.dstOffsets[2] = dstOffsets[2];

  return temp;
}

inline VkBufferImageCopy BufferImageCopy(
  VkDeviceSize bufferOffset,
  uint32_t bufferRowLength,
  uint32_t bufferImageHeight,
  VkImageSubresourceLayers imageSubresource,
  VkOffset3D imageOffset,
  VkExtent3D imageExtent
)
{
  VkBufferImageCopy temp;
  temp.bufferOffset = bufferOffset;
  temp.bufferRowLength = bufferRowLength;
  temp.bufferImageHeight = bufferImageHeight;
  temp.imageSubresource = imageSubresource;
  temp.imageOffset = imageOffset;
  temp.imageExtent = imageExtent;

  return temp;
}

inline VkImageResolve ImageResolve(
  VkImageSubresourceLayers srcSubresource,
  VkOffset3D srcOffset,
  VkImageSubresourceLayers dstSubresource,
  VkOffset3D dstOffset,
  VkExtent3D extent
)
{
  VkImageResolve temp;
  temp.srcSubresource = srcSubresource;
  temp.srcOffset = srcOffset;
  temp.dstSubresource = dstSubresource;
  temp.dstOffset = dstOffset;
  temp.extent = extent;

  return temp;
}

inline VkDescriptorSetLayoutBinding DescriptorSetLayoutBinding(
  uint32_t binding,
  VkDescriptorType descriptorType,
  uint32_t descriptorCount,
  VkShaderStageFlags stageFlags,
  const VkSampler * pImmutableSamplers
)
{
  VkDescriptorSetLayoutBinding temp;
  temp.binding = binding;
  temp.descriptorType = descriptorType;
  temp.descriptorCount = descriptorCount;
  temp.stageFlags = stageFlags;
  temp.pImmutableSamplers = pImmutableSamplers;

  return temp;
}

inline VkDescriptorPoolSize DescriptorPoolSize(
  VkDescriptorType type,
  uint32_t descriptorCount
)
{
  VkDescriptorPoolSize temp;
  temp.type = type;
  temp.descriptorCount = descriptorCount;

  return temp;
}

inline VkSpecializationMapEntry SpecializationMapEntry(
  uint32_t constantID,
  uint32_t offset,
  size_t size
)
{
  VkSpecializationMapEntry temp;
  temp.constantID = constantID;
  temp.offset = offset;
  temp.size = size;

  return temp;
}

inline VkSpecializationInfo SpecializationInfo(
  uint32_t mapEntryCount,
  const VkSpecializationMapEntry * pMapEntries,
  size_t dataSize,
  const void * pData
)
{
  VkSpecializationInfo temp;
  temp.mapEntryCount = mapEntryCount;
  temp.pMapEntries = pMapEntries;
  temp.dataSize = dataSize;
  temp.pData = pData;

  return temp;
}

inline VkVertexInputBindingDescription VertexInputBindingDescription(
  uint32_t binding,
  uint32_t stride,
  VkVertexInputRate inputRate
)
{
  VkVertexInputBindingDescription temp;
  temp.binding = binding;
  temp.stride = stride;
  temp.inputRate = inputRate;

  return temp;
}

inline VkVertexInputAttributeDescription VertexInputAttributeDescription(
  uint32_t location,
  uint32_t binding,
  VkFormat format,
  uint32_t offset
)
{
  VkVertexInputAttributeDescription temp;
  temp.location = location;
  temp.binding = binding;
  temp.format = format;
  temp.offset = offset;

  return temp;
}

inline VkPipelineColorBlendAttachmentState PipelineColorBlendAttachmentState(
  VkBool32 blendEnable,
  VkBlendFactor srcColorBlendFactor,
  VkBlendFactor dstColorBlendFactor,
  VkBlendOp colorBlendOp,
  VkBlendFactor srcAlphaBlendFactor,
  VkBlendFactor dstAlphaBlendFactor,
  VkBlendOp alphaBlendOp,
  VkColorComponentFlags colorWriteMask
)
{
  VkPipelineColorBlendAttachmentState temp;
  temp.blendEnable = blendEnable;
  temp.srcColorBlendFactor = srcColorBlendFactor;
  temp.dstColorBlendFactor = dstColorBlendFactor;
  temp.colorBlendOp = colorBlendOp;
  temp.srcAlphaBlendFactor = srcAlphaBlendFactor;
  temp.dstAlphaBlendFactor = dstAlphaBlendFactor;
  temp.alphaBlendOp = alphaBlendOp;
  temp.colorWriteMask = colorWriteMask;

  return temp;
}

inline VkStencilOpState StencilOpState(
  VkStencilOp failOp,
  VkStencilOp passOp,
  VkStencilOp depthFailOp,
  VkCompareOp compareOp,
  uint32_t compareMask,
  uint32_t writeMask,
  uint32_t reference
)
{
  VkStencilOpState temp;
  temp.failOp = failOp;
  temp.passOp = passOp;
  temp.depthFailOp = depthFailOp;
  temp.compareOp = compareOp;
  temp.compareMask = compareMask;
  temp.writeMask = writeMask;
  temp.reference = reference;

  return temp;
}

inline VkPushConstantRange PushConstantRange(
  VkShaderStageFlags stageFlags,
  uint32_t offset,
  uint32_t size
)
{
  VkPushConstantRange temp;
  temp.stageFlags = stageFlags;
  temp.offset = offset;
  temp.size = size;

  return temp;
}

inline VkClearDepthStencilValue ClearDepthStencilValue(
  float depth,
  uint32_t stencil
)
{
  VkClearDepthStencilValue temp;
  temp.depth = depth;
  temp.stencil = stencil;

  return temp;
}

inline VkClearAttachment ClearAttachment(
  VkImageAspectFlags aspectMask,
  uint32_t colorAttachment,
  VkClearValue clearValue
)
{
  VkClearAttachment temp;
  temp.aspectMask = aspectMask;
  temp.colorAttachment = colorAttachment;
  temp.clearValue = clearValue;

  return temp;
}

inline VkAttachmentDescription AttachmentDescription(
  VkAttachmentDescriptionFlags flags,
  VkFormat format,
  VkSampleCountFlagBits samples,
  VkAttachmentLoadOp loadOp,
  VkAttachmentStoreOp storeOp,
  VkAttachmentLoadOp stencilLoadOp,
  VkAttachmentStoreOp stencilStoreOp,
  VkImageLayout initialLayout,
  VkImageLayout finalLayout
)
{
  VkAttachmentDescription temp;
  temp.flags = flags;
  temp.format = format;
  temp.samples = samples;
  temp.loadOp = loadOp;
  temp.storeOp = storeOp;
  temp.stencilLoadOp = stencilLoadOp;
  temp.stencilStoreOp = stencilStoreOp;
  temp.initialLayout = initialLayout;
  temp.finalLayout = finalLayout;

  return temp;
}

inline VkAttachmentReference AttachmentReference(
  uint32_t attachment,
  VkImageLayout layout
)
{
  VkAttachmentReference temp;
  temp.attachment = attachment;
  temp.layout = layout;

  return temp;
}

inline VkSubpassDescription SubpassDescription(
  VkSubpassDescriptionFlags flags,
  VkPipelineBindPoint pipelineBindPoint,
  uint32_t inputAttachmentCount,
  const VkAttachmentReference * pInputAttachments,
  uint32_t colorAttachmentCount,
  const VkAttachmentReference * pColorAttachments,
  const VkAttachmentReference * pResolveAttachments,
  const VkAttachmentReference * pDepthStencilAttachment,
  uint32_t preserveAttachmentCount,
  const uint32_t * pPreserveAttachments
)
{
  VkSubpassDescription temp;
  temp.flags = flags;
  temp.pipelineBindPoint = pipelineBindPoint;
  temp.inputAttachmentCount = inputAttachmentCount;
  temp.pInputAttachments = pInputAttachments;
  temp.colorAttachmentCount = colorAttachmentCount;
  temp.pColorAttachments = pColorAttachments;
  temp.pResolveAttachments = pResolveAttachments;
  temp.pDepthStencilAttachment = pDepthStencilAttachment;
  temp.preserveAttachmentCount = preserveAttachmentCount;
  temp.pPreserveAttachments = pPreserveAttachments;

  return temp;
}

inline VkSubpassDependency SubpassDependency(
  uint32_t srcSubpass,
  uint32_t dstSubpass,
  VkPipelineStageFlags srcStageMask,
  VkPipelineStageFlags dstStageMask,
  VkAccessFlags srcAccessMask,
  VkAccessFlags dstAccessMask,
  VkDependencyFlags dependencyFlags
)
{
  VkSubpassDependency temp;
  temp.srcSubpass = srcSubpass;
  temp.dstSubpass = dstSubpass;
  temp.srcStageMask = srcStageMask;
  temp.dstStageMask = dstStageMask;
  temp.srcAccessMask = srcAccessMask;
  temp.dstAccessMask = dstAccessMask;
  temp.dependencyFlags = dependencyFlags;

  return temp;
}

inline VkDrawIndirectCommand DrawIndirectCommand(
  uint32_t vertexCount,
  uint32_t instanceCount,
  uint32_t firstVertex,
  uint32_t firstInstance
)
{
  VkDrawIndirectCommand temp;
  temp.vertexCount = vertexCount;
  temp.instanceCount = instanceCount;
  temp.firstVertex = firstVertex;
  temp.firstInstance = firstInstance;

  return temp;
}

inline VkDrawIndexedIndirectCommand DrawIndexedIndirectCommand(
  uint32_t indexCount,
  uint32_t instanceCount,
  uint32_t firstIndex,
  int32_t vertexOffset,
  uint32_t firstInstance
)
{
  VkDrawIndexedIndirectCommand temp;
  temp.indexCount = indexCount;
  temp.instanceCount = instanceCount;
  temp.firstIndex = firstIndex;
  temp.vertexOffset = vertexOffset;
  temp.firstInstance = firstInstance;

  return temp;
}

inline VkDispatchIndirectCommand DispatchIndirectCommand(
  uint32_t x,
  uint32_t y,
  uint32_t z
)
{
  VkDispatchIndirectCommand temp;
  temp.x = x;
  temp.y = y;
  temp.z = z;

  return temp;
}

inline VkDisplayModeParametersKHR DisplayModeParametersKHR(
  VkExtent2D visibleRegion,
  uint32_t refreshRate
)
{
  VkDisplayModeParametersKHR temp;
  temp.visibleRegion = visibleRegion;
  temp.refreshRate = refreshRate;

  return temp;
}

///@}

} // namespace Krust

#endif // #ifndef KRUST_STRUCT_INIT_H_INCLUDED_E26EF
